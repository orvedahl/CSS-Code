
PRO COLOR_VOODOO
	DEVICE, true_color=24
	DEVICE,decomposed=0
END

PRO GET_STATE_CTM,state, FRESH = fresh, N_RED = n_red,N_GREEN = n_green,N_BLUE = n_blue
	COMMON TEST_BLOCK, red_arr, red_locs,green_arr,green_locs,blue_arr,blue_locs, $
				red,green,blue, ctm_top
	IF (NOT KEYWORD_SET(N_RED)) THEN n_red   = 16
	IF (NOT KEYWORD_SET(N_GREEN)) THEN n_green = 16
	IF (NOT KEYWORD_SET(N_BLUE)) THEN n_blue  = 16
	save_file = 'state.save'    ; This file stores all the state information - name it whatever.
	exist = findfile(save_file)
	IF (EXIST ne '' and (NOT KEYWORD_SET(FRESH))) THEN BEGIN  ; Restore the previous state.
		RESTORE, FILENAME = save_file
		RETURN
	ENDIF ELSE BEGIN     ;No previous state - need to initialize the program state.
		x_size     = 300   ; x size for the draw widgets
		y_size = 50   ; y size for the draw widgets that contain the rgb plots
		y_size_bar = 50   ; y size for the color bar draw widget

		rgb_x_one  = 0     ; x and y coordinates for the plotting window within the draw widgets
		rgb_y_one  = 0     ; Size is in pixels
		rgb_x_size  = x_size  ; x and y sizes for plotting rgb plots within the draw widgets
		rgb_y_size  = y_size_bar  ; Note that the size of the color bar is identical in the x-dimension
 
		bar_size_y = 300   ; Color bar y size (in pixels)
		location     = 0   ; location of current dot within current graphics window
		down         = 0   ; Left mouse button not down
		up           = 1   ; Left mouse button is up
		r_window     = 0   ; Index for red rgb plot window
		g_window     = 0   ; Index for green rgb plot window
		b_window     = 0   ; Index for blue rgb plot window
		bar_window   = 0   ; Index for color bar window
		top_widget   = 0L  ; Widget ID for the top level base widget
		top_exists   = 0   ; Existence tag for the top level base widget
		table_file   = 'ct42.bin'  ; Current color table file loaded - null string if none.

                SPAWN, 'pwd', color_table_path
		;color_table_path = '/home3/feathern/ASH/ANALYSIS/COLOR_TABLES'  ; color table directory

		dot_dist     = 1.0 ; The closest dots are allowed to be next to each other
				   ; This prevents crossing of dots and divide by zero errors


		value = BYTARR(3,256)  ; Events generated by this compound widget have a value that
					; is current rgb color table within the widget.
					; value[0,*] is red, [1,*] is green, [2,*] is blue
		state = {x_size:x_size,y_size:y_size,y_size_bar:y_size_bar,location:location, $
			 down:down,up:up,rgb_x_one:rgb_x_one, rgb_y_one:rgb_y_one, $
			 rgb_x_size:rgb_x_size,rgb_y_size:rgb_y_size,bar_size_y:bar_size_y, $ 
			 r_window:r_window,g_window:g_window,b_window:b_window,bar_window:bar_window, $
			 top_widget:top_widget,top_exists:top_exists,table_file:table_file, $
			 color_table_path:color_table_path,save_file:save_file,dot_dist:dot_dist,value:value}
		
		red_arr    = fltarr(n_red)              ; The initial dot values
		red_arr[*] = 10.0			    
		red_locs   = findgen(n_red)*255.0/(n_red-1.0)  ; The initial dot coordinates
		blue_arr   = FLTARR(n_blue)		       ; These arrays are allowed to vary in size,
		blue_arr[*] = 10.0			       ; and so are passed through a common block
		blue_locs   = findgen(n_blue)*255.0/(n_blue-1.0) 

		green_arr  = FLTARR(n_green)		     
		green_arr[*] = 10.0			    
		green_locs   = INDGEN(n_green)*255.0/(n_green-1.0) 

		red        = BYTARR(256)	     ; The rgb color tables
		red[*]     = 10
		green      = red
		blue       = red

	ENDELSE
END


PRO REFRESH_VIEW,state,base0,BASE_WIDGET = base_widget,UVALUE = UVALUE
	COMMON TEST_BLOCK, red_arr, red_locs,green_arr,green_locs,blue_arr,blue_locs, $
				red,green,blue,ctm_top

	IF (state.top_exists) THEN WIDGET_CONTROL,state.top_widget,/DESTROY 

	file_menu_options = [ '1\File' , $
	         '0\Load Color Table..' , $
	         '0\Save Table As..', $
	         '2\Exit' ]
        base0 = WIDGET_BASE(base_widget,/COLUMN,UVALUE = UVALUE,EVENT_FUNC='CTM_EVENT', $ 
         					FUNC_GET_VALUE='CTM_GET_VALUE', $ 
         					PRO_SET_VALUE='CTM_SET_VALUE')
	base = WIDGET_BASE(base0,/COLUMN,UVALUE = state)
	ctm_top = base
	options_row  = WIDGET_BASE(base,/ROW,uvalue = 'opt')
	file_menu    = CW_PDMENU(options_row, file_menu_options, $
	                /RETURN_NAME,UVALUE ='file menu' )
	red_plot     = WIDGET_DRAW(base,xsize = state.x_size,ysize = state.y_size, UVALUE = 'red'  ,/BUTTON_EVENTS,/MOTION_EVENTS)
	green_plot   = WIDGET_DRAW(base,xsize = state.x_size,ysize = state.y_size, UVALUE = 'green',/BUTTON_EVENTS,/MOTION_EVENTS)
	blue_plot    = WIDGET_DRAW(base,xsize = state.x_size,ysize = state.y_size, UVALUE = 'blue' ,/BUTTON_EVENTS,/MOTION_EVENTS)
	cbar  = WIDGET_DRAW(base,xsize = state.x_size,ysize = state.y_size)

	contextBase = WIDGET_BASE(red_plot, /CONTEXT_MENU)
	button1 = WIDGET_BUTTON(contextBase, VALUE='Add Dot')
	button2 = WIDGET_BUTTON(contextBase, VALUE='Remove Dot')
	contextBase = WIDGET_BASE(blue_plot, /CONTEXT_MENU)
	button1 = WIDGET_BUTTON(contextBase, VALUE='Add Dot')
	button2 = WIDGET_BUTTON(contextBase, VALUE='Remove Dot')
	contextBase = WIDGET_BASE(green_plot, /CONTEXT_MENU)
	button1 = WIDGET_BUTTON(contextBase, VALUE='Add Dot')
	button2 = WIDGET_BUTTON(contextBase, VALUE='Remove Dot')
        
	WIDGET_CONTROL,base,/REALIZE

	WIDGET_CONTROL , red_plot   , get_value = index_red                                                                                           
	WIDGET_CONTROL , green_plot , get_value = index_green                                                                                         
	WIDGET_CONTROL , blue_plot  , get_value = index_blue
	WIDGET_CONTROL , cbar       , get_value = index_bar                                                                                           

	state.bar_window = index_bar
	state.r_window   = index_red
	state.g_window   = index_green
	state.b_window   = index_blue
        state.top_widget = base
	WIDGET_CONTROL,base, SET_UVALUE = state

	indices = [index_red,index_green,index_blue]
	pcolors = [250,170,100]
	location = [state.rgb_x_one,state.rgb_y_one,state.rgb_x_one+state.rgb_x_size,state.rgb_y_one+state.rgb_y_size]

	LOADCT,13,/SILENT

	WSET,index_red
	PLOT, red, POS = location,/DEVICE,XRANGE = [0,255],XSTYLE = 1, $
		YRANGE = [0,255], YSTYLE = 5, COLOR = pcolors[0], THICK = 2
	OPLOT, red_locs, red_arr,PSYM  = 4,THICK = 2,COLOR = 200


	WSET,index_green
	PLOT, green, POS = location,/DEVICE,XRANGE = [0,255],XSTYLE = 1, $
		YRANGE = [0,255], YSTYLE = 5, COLOR = pcolors[1], THICK = 2
	OPLOT, green_locs, green_arr,PSYM  = 4,THICK = 2,COLOR = 200


	WSET,index_blue
	PLOT, blue, POS = location,/DEVICE,XRANGE = [0,255],XSTYLE = 1, $
		YRANGE = [0,255], YSTYLE = 5, COLOR = pcolors[2], THICK = 2
	OPLOT, blue_locs, blue_arr,PSYM  = 4,THICK = 2,COLOR = 200

	TVLCT,red,green,blue
	WSET,index_bar
	img = INDGEN(256)#MAKE_ARRAY(10,value = 1)
	rgb_size_x = state.rgb_x_size
        img = CONGRID(img,rgb_size_x,state.bar_size_y)


	TV,img
;	XMANAGER, 'base_ct', base, /no_block, GROUP_LEADER = GROUP_LEADER 
END

PRO CTM_SET_VALUE, id, value
    COMMON TEST_BLOCK, red_arr,red_locs,green_arr,green_locs,blue_arr,blue_locs,red,green,blue, ctm_top
    red_arr = value.r_arr
    red_locs = value.r_locs
    green_arr = value.g_arr
    green_locs = value.g_locs
    blue_arr = value.b_arr
    blue_locs = value.b_locs
    table = value.table
    red = reform(table(1,*))
    green = reform(table(2,*))
    blue = reform(table(3,*))
    child = WIDGET_INFO(id, /CHILD)
    WIDGET_CONTROL, child, GET_UVALUE=state
    UPDATE_PLOTS, state, COLOR='red'
    UPDATE_PLOTS, state, COLOR='green'
    UPDATE_PLOTS, state, COLOR='blue'
END

FUNCTION CTM_GET_VALUE,id
    COMMON TEST_BLOCK, red_arr,red_locs,green_arr,green_locs,blue_arr,blue_locs,red,green,blue, ctm_top
    TVLCT, r, g, b, /GET
    table = bytarr(3,256)
    table = [[r],[g],[b]] 
    val = {CTM_VAL,table:table,r_locs:red_locs,g_locs:green_locs,b_locs:blue_locs, r_arr:red_arr,g_arr:green_arr,b_arr:blue_arr}
    return, val
END

PRO MAKE_MONOCOLOR_TABLE,dot_locs,dot_arr,color_table
	temp = SPL_INIT(dot_locs, dot_arr)
        color_table = SPL_INTERP(dot_locs,dot_arr, temp, BINDGEN(256))
        loc_zero = WHERE(color_table lt 0)
        loc_255 = WHERE(color_table gt 255)
	color_table = byte(color_table)
        IF (MIN(loc_zero) NE -1) THEN color_table[loc_zero] = 0
        IF (MIN(loc_255) NE -1)  THEN color_table[loc_255]  = 255	
END


FUNCTION CTM_EVENT,ev
	COMMON TEST_BLOCK, red_arr, red_locs,green_arr,green_locs,blue_arr,blue_locs, red,green,blue, ctm_top
	WIDGET_CONTROL, ev.id, GET_UVALUE = uvalue
	CASE uvalue OF
		'red'   : RGB_PLOT, ev,uvalue
		'blue'  : RGB_PLOT, ev,uvalue
		'green' : RGB_PLOT, ev,uvalue
		'file menu'   : fmenu,ev 
	ENDCASE
	WIDGET_CONTROL,ctm_top,GET_UVALUE = state

	IF (uvalue eq 'red' or uvalue eq 'blue' or uvalue eq 'green') THEN BEGIN
		IF (ev.type eq 2 and state.down eq 1) THEN BEGIN
			base0 = ev.handler
			TVLCT, r, g, b, /GET
			table = bytarr(3,256)
			table = [[r],[g],[b]]
			val = {CTM_VAL,table:table,r_locs:red_locs,g_locs:green_locs,b_locs:blue_locs, $
				r_arr:red_arr,g_arr:green_arr,b_arr:blue_arr}
                        ret = { CTM_EVENT, ID:base0, TOP:ev.top, HANDLER:0L, VALUE:val}
			RETURN, ret
		ENDIF
	ENDIF
        
        if(uvalue eq 'file menu') then begin
           base0 = ev.handler
	   TVLCT, r, g, b, /GET
           table = bytarr(3,256)
           table = [[r],[g],[b]]
           val = {CTM_VAL,table:table,r_locs:red_locs,g_locs:green_locs,b_locs:blue_locs,r_arr:red_arr,g_arr:green_arr,b_arr:blue_arr}
           ret = { CTM_EVENT, ID:base0, TOP:ev.top, HANDLER:0L, VALUE:val} 
           return, ret
        endif
END


PRO FMENU, ev
      CASE ev.value OF
        'Load Color Table..' : Load_New_Color_Table,ev
        'Save Table As..'    : Save_Current_Color_Table,ev
        'Exit'		     : EXIT_SEQUENCE,ev
      ENDCASE
END

PRO EXIT_SEQUENCE,ev
	COMMON TEST_BLOCK, red_arr, red_locs, green_arr,green_locs,blue_arr,blue_locs, $
				red,green,blue,ctm_top
	WIDGET_CONTROL,ctm_top,GET_UVALUE = state
	state.top_exists = 0
	SAVE, FILENAME = state.save_file,state,red_arr,red_locs,green_arr,green_locs,blue_arr,blue_locs, $
			   red,green,blue
	WIDGET_CONTROL, ctm_top,/DESTROY	
END

PRO READ_COLOR_TABLE_FILE,file,ctr,ctg,ctb
	ctr=BYTARR(256) & ctg=ctr & ctb=ctr
	CLOSE,3 & OPENR,3,file
	READU,3,ctr,ctg,ctb
	CLOSE,3	
END

PRO WRITE_COLOR_TABLE_FILE,file,ctr,ctg,ctb
	CLOSE,3 & OPENW,3,file
	WRITEU,3,ctr,ctg,ctb
	CLOSE,3	
END

PRO SAVE_CURRENT_COLOR_TABLE,ev
	COMMON TEST_BLOCK, red_arr,red_locs,green_arr,green_locs,blue_arr,blue_locs, $
			   red, green,blue,ctm_top
	WIDGET_CONTROL,ctm_top,GET_UVALUE = state
	path = state.color_table_path
        color_table_file = DIALOG_PICKFILE(PATH = path,FILE = state.table_file,FILTER='*.bin',/FIX_FILTER)
        IF (color_table_file eq '') THEN RETURN     ; The User Hit The Cancel Button
	WRITE_COLOR_TABLE_FILE,color_table_file,red,green,blue
	state.table_file = color_table_file
	WIDGET_CONTROL,ctm_top,SET_UVALUE = state
END

PRO LOAD_NEW_COLOR_TABLE,ev
	COMMON TEST_BLOCK, red_arr,red_locs,green_arr,green_locs,blue_arr,blue_locs, $
				red,green,blue,ctm_top
	;color_table_file = '/home3/feathern/ASH/ANALYSIS/COLOR_TABLES/ct42.bin'
	WIDGET_CONTROL,ctm_top,GET_UVALUE = state
	; Prompt user for color table filename

	path = state.color_table_path
        color_table_file = DIALOG_PICKFILE(PATH = path,FILTER='*.bin',/FIX_FILTER)
	IF (color_table_file eq '') THEN RETURN     ; The User Hit The Cancel Button

	state.table_file = color_table_file
	READ_COLOR_TABLE_FILE,color_table_file,red,green,blue
	TVLCT,red,green,blue

	n_red   = N_ELEMENTS(red_locs)
	n_blue  = N_ELEMENTS(blue_locs)
	n_green = N_ELEMENTS(green_locs)
	red_locs   = indgen(n_red)*fix(255d0/double(n_red-1))
	green_locs = indgen(n_green)*fix(255d0/double(n_green-1))
	blue_locs  = indgen(n_blue)*fix(255d0/double(n_blue-1))

	FOR i = 0, n_red-1 DO BEGIN
	    red_arr[i]   = red[red_locs[i]]
	ENDFOR
	FOR i = 0, n_green-1 DO BEGIN
	    green_arr[i] = green[green_locs[i]]
	    blue_arr[i]  = blue[blue_locs[i]]
	ENDFOR
	FOR i = 0, n_blue-1 DO BEGIN
	    blue_arr[i]  = blue[blue_locs[i]]
	ENDFOR

	; refresh the displays
	UPDATE_PLOTS, state, COLOR = 'red'
	UPDATE_PLOTS, state, COLOR = 'green'
	UPDATE_PLOTS, state, COLOR = 'blue'
;	state.top_exists = 1
	WIDGET_CONTROL,ctm_top,SET_UVALUE = state
;	REFRESH_VIEW,state    

END

PRO ADD_REMOVE_DOT,dot_locs,dot_arr,ADD = ADD, REMOVE = REMOVE
	add = 0
	remove = 0
	IF (KEYWORD_SET(ADD))    THEN add = 1
	IF (KEYWORD_SET(REMOVE)) THEN remove = 1
END

PRO RGB_PLOT, ev,color
	COMMON TEST_BLOCK, red_arr,red_locs,green_arr,green_locs,blue_arr,blue_locs, $
				red,green,blue,ctm_top
;	ev.press = 4 for right button press
	CASE color OF
		'red'   : dot_locs = red_locs
		'green' : dot_locs = green_locs
		'blue'  : dot_locs = blue_locs
	ENDCASE
	CASE color OF
		'red'   : dot_arr = red_arr
		'green' : dot_arr = green_arr
		'blue'  : dot_arr = blue_arr
	ENDCASE
	WIDGET_CONTROL,ev.id, get_value = index
	WSET,index
	WIDGET_CONTROL,ctm_top,GET_UVALUE = state
	xconv = (state.rgb_x_size)/255.0	
	d2 = dot_locs*xconv+state.rgb_x_one                ; dot locations in pixels
	yconv = (state.rgb_y_size)/255.0
	IF (ev.release eq 4) THEN BEGIN   ; FOR adding and removing dots
;		contextBase = WIDGET_BASE(ev.id, /CONTEXT_MENU)  
;		button1 = WIDGET_BUTTON(contextBase, VALUE='Add Dot')  
;		button2 = WIDGET_BUTTON(contextBase, VALUE='Remove Dot')
;		WIDGET_DISPLAYCONTEXTMENU, ev.ID, ev.X, ev.Y, contextBase  	
;		CASE color OF
;			'red'  : add_remove_dot,red_locs,red_arr, add/remove
;			'green': add_remove_dot,green_locs,green_arr,add/remove
;			'blue' : add_remove_dot,blue_locs,blue_arr,add/remove
;		ENDCASE 
	ENDIF
	IF (ev.press eq 1) THEN BEGIN
		;Left Mouse Button Pressed - identify dot to move
		diff = abs(ev.x-d2)
		loc = where(diff eq min(diff))
		state.location = loc
		state.down = 1
		state.up   = 0
		WIDGET_CONTROL,ctm_top,SET_UVALUE = state
	ENDIF
	IF (ev.type eq 2) THEN BEGIN
		 ;Mouse is in motion.
		 IF (state.down eq 1) THEN BEGIN
			 ;Left mouse button is down - we are dragging a dot.

			loc           = state.location
			dot_dist = state.dot_dist
			dot_max = 255
			dot_min = 0
			
			IF dot_locs[loc] NE MAX(dot_locs) THEN BEGIN
				 dot_max = dot_locs[loc+1]-dot_dist
			ENDIF
			IF dot_locs[loc] NE MIN(dot_locs) THEN BEGIN
				 dot_min = dot_locs[loc-1]+dot_dist
			ENDIF

		        dot_locs(loc) = MIN([(ev.x-state.rgb_x_one)/xconv,dot_max])
			dot_locs(loc) = MAX([dot_locs(loc),dot_min])
			dot_arr(loc)  = (ev.y-state.rgb_y_one)/yconv
			dot_arr(loc)  = MAX([dot_arr(loc),0])
			dot_arr(loc)  = MIN([dot_arr(loc),255])
			; store the new locations and values into the correct variable
        		CASE color OF
                		'red'  :  red_locs = dot_locs
                		'green' : green_locs = dot_locs
                		'blue'  : blue_locs = dot_locs
			ENDCASE
        		CASE color OF
                		'red'   : red_arr   = dot_arr
                		'green' : green_arr = dot_arr
                		'blue'  : blue_arr  = dot_arr
        		ENDCASE

			temp          = SPL_INIT(dot_locs, dot_arr)

			MAKE_MONOCOLOR_TABLE,dot_locs,dot_arr,color_table
			location = [state.rgb_x_one,state.rgb_y_one,state.rgb_x_one+state.rgb_x_size,state.rgb_y_one+state.rgb_y_size]
	 		LOADCT,13,/SILENT 

			IF color EQ 'red'   THEN pcolor = 250
			IF color EQ 'blue'  THEN pcolor = 100
			IF color EQ 'green' THEN pcolor = 170

			PLOT, color_table, pos = location,/device,xrange = [0,255],xstyle = 1, $
	                      yrange = [0,255], ystyle = 5, thick = 2,color = pcolor
			OPLOT, dot_locs, dot_arr,psym  = 4, thick = 2,color = 200
			; display the color table
			MAKE_MONOCOLOR_TABLE,red_locs  ,red_arr   ,red
			MAKE_MONOCOLOR_TABLE,blue_locs ,blue_arr  ,blue
			MAKE_MONOCOLOR_TABLE,green_locs,green_arr ,green


			full_table = [[red],[green],[blue]]
			loc_zero = WHERE(full_table lt 0)
			loc_255  = WHERE(full_table gt 255)
			IF (MIN(loc_zero) ne -1) THEN full_ctab[loc_zero] = 0
			IF (MIN(loc_255) ne -1)  THEN full_ctab[loc_255]  = 255
			TVLCT,full_table
			img = INDGEN(256)#MAKE_ARRAY(10,value = 1)
			rgb_size_x = state.rgb_x_size
			img = CONGRID(img,rgb_size_x,state.bar_size_y)
			WSET,state.bar_window
			TV,img
		 ENDIF
	
	ENDIF
	IF (ev.press eq 0 and ev.type ne 2) THEN BEGIN 
	; Button has been released and the mouse is no longer in motion.
		state.up = 1
		state.down = 0
		WIDGET_CONTROL,ctm_top,SET_UVALUE = state
	ENDIF

END

PRO UPDATE_PLOTS, state, COLOR = COLOR
	COMMON TEST_BLOCK, red_arr,red_locs,green_arr,green_locs,blue_arr,blue_locs, $
				red,green,blue,ctm_top
         location = [state.rgb_x_one,state.rgb_y_one,state.rgb_x_one+state.rgb_x_size,state.rgb_y_one+state.rgb_y_size]
         LOADCT,13,/SILENT
	 IF (COLOR EQ 'red') THEN BEGIN
		pcolor = 250
		wset,state.r_window
		dot_locs = red_locs
		dot_arr = red_arr
	 ENDIF
	 IF (COLOR EQ 'green') THEN BEGIN
		pcolor = 170
		wset,state.g_window
		dot_locs = green_locs
		dot_arr = green_arr
	 ENDIF
	 IF (COLOR EQ 'blue') THEN BEGIN
		pcolor = 100
		wset,state.b_window
		dot_locs = blue_locs
		dot_arr = blue_arr
	 ENDIF
	 MAKE_MONOCOLOR_TABLE,dot_locs,dot_arr,color_table

         PLOT, color_table, pos = location,/device,xrange = [0,255],xstyle = 1, $
                 yrange = [0,255], ystyle = 5, thick = 2,color = pcolor
         OPLOT, dot_locs, dot_arr,psym  = 4, thick = 2,color = 200
         ; display the color table
         MAKE_MONOCOLOR_TABLE,red_locs  ,red_arr   ,red
         MAKE_MONOCOLOR_TABLE,blue_locs ,blue_arr  ,blue
         MAKE_MONOCOLOR_TABLE,green_locs,green_arr ,green
	 full_table = [[red],[green],[blue]]
         loc_zero = WHERE(full_table lt 0)
         loc_255  = WHERE(full_table gt 255) 
         IF (MIN(loc_zero) ne -1) THEN full_ctab[loc_zero] = 0
         IF (MIN(loc_255) ne -1)  THEN full_ctab[loc_255]  = 255
         TVLCT,full_table
         img = INDGEN(256)#MAKE_ARRAY(10,value = 1)
         rgb_size_x = state.rgb_x_size                                                                                      
         img = CONGRID(img,rgb_size_x,state.bar_size_y)
         WSET,state.bar_window
         TV,img


END

FUNCTION CTMAKER,FRESH = fresh, N_RED = n_red,N_BLUE = n_blue, N_GREEN = n_green,BASE_WIDGET = base_widget,UVALUE = UVALUE
	; Set keyword fresh to load a clean state (zeroed color table)
	COMMON TEST_BLOCK, red_arr, red_locs, green_arr,green_locs,blue_arr,blue_locs,red,green,blue,ctm_top
	DOCOLOR
	GET_STATE_CTM,state,FRESH = fresh,N_RED = n_red,N_blue = n_blue, N_GREEN = n_green

	REFRESH_VIEW,state,base0,BASE_WIDGET = base_widget,UVALUE = UVALUE

	path = state.color_table_path
        color_table_file = path+'/ct42new.bin' 

	state.table_file = color_table_file
	READ_COLOR_TABLE_FILE,color_table_file,red,green,blue
	TVLCT,red,green,blue

	n_red   = N_ELEMENTS(red_locs)
	n_blue  = N_ELEMENTS(blue_locs)
	n_green = N_ELEMENTS(green_locs)
	red_locs   = indgen(n_red)*fix(255d0/double(n_red-1))
	green_locs = indgen(n_green)*fix(255d0/double(n_green-1))
	blue_locs  = indgen(n_blue)*fix(255d0/double(n_blue-1))

	FOR i = 0, n_red-1 DO BEGIN
	    red_arr[i]   = red[red_locs[i]]
	ENDFOR
	FOR i = 0, n_green-1 DO BEGIN
	    green_arr[i] = green[green_locs[i]]
	    blue_arr[i]  = blue[blue_locs[i]]
	ENDFOR
	FOR i = 0, n_blue-1 DO BEGIN
	    blue_arr[i]  = blue[blue_locs[i]]
	ENDFOR

	; refresh the displays
	UPDATE_PLOTS, state, COLOR = 'red'
	UPDATE_PLOTS, state, COLOR = 'green'
	UPDATE_PLOTS, state, COLOR = 'blue'

	RETURN,base0
END

	
